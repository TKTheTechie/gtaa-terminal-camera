import type { VideoFrame, SolaceConfig, StatusResponse } from './types';
import { DEMO_MODE } from './config';
import * as solace from 'solclientjs';

export class SolaceVideoClient {
  private session: solace.Session | null = null;
  private sessionEventCb: any = null;
  private messageEventCb: any = null;
  private frameChunks: Map<string, Map<number, string>> = new Map();
  private frameMetadata: Map<string, any> = new Map();
  private onFrameCallback?: (imageData: string) => void;
  private isConnected = false;
  private subscriptions: Set<string> = new Set();
  private demoInterval?: number;
  private pendingRequests: Map<string, (response: any) => void> = new Map();
  private factoryInitialized = false;

  constructor(private config: SolaceConfig) {
    // Initialize the solace client library
    if (!DEMO_MODE) {
      this.initializeSolaceFactory();
    }
  }

  private initializeSolaceFactory(): void {
    if (this.factoryInitialized) {
      console.log('Solace factory already initialized');
      return;
    }

    try {
      console.log('Initializing Solace factory...');
      // @ts-ignore
      const factoryProps = new solace.SolclientFactoryProperties();
      factoryProps.profile = solace.SolclientFactoryProfiles.version10;
      solace.SolclientFactory.init(factoryProps);
      this.factoryInitialized = true;
      console.log('‚úÖ Solace factory initialized');
    } catch (error) {
      console.error('‚ùå Failed to initialize Solace factory:', error);
      throw error;
    }
  }

  private async initializeSolace(): Promise<void> {
    if (DEMO_MODE) {
      console.log('üé≠ Demo mode enabled - Solace factory not initialized');
      return;
    }

    // Factory is already initialized in constructor
    if (!this.factoryInitialized) {
      this.initializeSolaceFactory();
    }
  }

  async connect(): Promise<void> {
    if (DEMO_MODE) {
      return this.connectDemo();
    }

    // Initialize Solace factory first
    await this.initializeSolace();

    return new Promise((resolve, reject) => {
      try {
        if (typeof window === 'undefined') {
          throw new Error('Window object not available (SSR context)');
        }

        if (!this.solaceApi) {
          throw new Error('Solace JavaScript API not loaded. Check if the library is installed.');
        }

        console.log('Initializing Solace connection...');
        console.log('Broker URL:', this.config.url);
        console.log('VPN:', this.config.vpnName);
        console.log('Username:', this.config.username);

        // Create session properties
        const sessionProperties = new this.solaceApi.SessionProperties({
          url: this.config.url,
          vpnName: this.config.vpnName,
          userName: this.config.username,
          password: this.config.password,
          connectRetries: 3,
          reconnectRetries: 3,
          reconnectRetryWaitInMsecs: 3000
        });

        console.log('Creating Solace session...');

        // Create session
        this.session = this.solaceApi.SolclientFactory.createSession(sessionProperties);

        // Session event callback
        this.sessionEventCb = (sessionEvent: any) => {
          console.log('Solace session event:', sessionEvent.type, sessionEvent.infoStr || '');
          
          switch (sessionEvent.type) {
            case this.solaceApi.SessionEventCode.UP_NOTICE:
              console.log('‚úÖ Solace session connected successfully');
              this.isConnected = true;
              resolve();
              break;
              
            case this.solaceApi.SessionEventCode.CONNECT_FAILED_ERROR:
              console.error('‚ùå Solace connection failed:', sessionEvent.infoStr);
              this.isConnected = false;
              reject(new Error(`Connection failed: ${sessionEvent.infoStr}`));
              break;
              
            case this.solaceApi.SessionEventCode.DISCONNECTED:
              console.log('‚ö†Ô∏è Solace session disconnected');
              this.isConnected = false;
              break;
              
            case this.solaceApi.SessionEventCode.SUBSCRIPTION_ERROR:
              console.error('‚ùå Solace subscription error:', sessionEvent.infoStr);
              break;
              
            case this.solaceApi.SessionEventCode.SUBSCRIPTION_OK:
              console.log('‚úÖ Solace subscription successful');
              break;
          }
        };

        // Message event callback
        this.messageEventCb = (message: any) => {
          this.handleMessage(message);
        };

        // Connect session
        this.session.on(this.solaceApi.SessionEventCode.UP_NOTICE, this.sessionEventCb);
        this.session.on(this.solaceApi.SessionEventCode.CONNECT_FAILED_ERROR, this.sessionEventCb);
        this.session.on(this.solaceApi.SessionEventCode.DISCONNECTED, this.sessionEventCb);
        this.session.on(this.solaceApi.SessionEventCode.SUBSCRIPTION_ERROR, this.sessionEventCb);
        this.session.on(this.solaceApi.SessionEventCode.SUBSCRIPTION_OK, this.sessionEventCb);
        this.session.on(this.solaceApi.SessionEventCode.MESSAGE, this.messageEventCb);

        console.log('Attempting to connect to Solace PubSub+...');
        this.session.connect();

      } catch (error) {
        console.error('‚ùå Failed to create Solace session:', error);
        reject(error);
      }
    });
  }

  private async connectDemo(): Promise<void> {
    return new Promise((resolve) => {
      console.log('Running in demo mode - simulating Solace connection');
      setTimeout(() => {
        this.session = { connected: true, demo: true };
        this.isConnected = true;
        console.log('Demo Solace session connected');
        resolve();
      }, 1000);
    });
  }

  async requestStatus(requestTopic: string): Promise<StatusResponse> {
    const requestId = this.generateRequestId();
    const replyToTopic = `gtaa/camera/control/reply/${requestId}`;

    if (DEMO_MODE || (this.session && this.session.demo)) {
      console.log(`Demo mode: Requesting status on ${requestTopic} with reply-to ${replyToTopic}`);
      // Simulate response
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve({
            videoTopicPrefix: 'video/esp32',
            activeTopic: 'westjet',
            fullVideoTopic: 'video/esp32/westjet'
          });
        }, 500);
      });
    }

    return new Promise((resolve, reject) => {
      if (!this.session || !this.isConnected) {
        reject(new Error('Solace session not connected'));
        return;
      }

      try {
        // Subscribe to reply topic
        const replyDestination = this.solaceApi.SolclientFactory.createTopicDestination(replyToTopic);
        this.session.subscribe(replyDestination, true, replyToTopic, 10000);

        // Store pending request
        this.pendingRequests.set(requestId, (response: any) => {
          // Unsubscribe from reply topic
          this.session.unsubscribe(replyDestination, true, replyToTopic, 10000);
          resolve(response);
        });

        // Create and send request message
        const message = this.solaceApi.SolclientFactory.createMessage();
        const destination = this.solaceApi.SolclientFactory.createTopicDestination(requestTopic);
        
        message.setDestination(destination);
        message.setReplyTo(replyDestination);
        message.setBinaryAttachment(JSON.stringify({
          requestId,
          requestType: 'get_status'
        }));
        message.setDeliveryMode(this.solaceApi.MessageDeliveryModeType.DIRECT);
        
        this.session.send(message);
        console.log(`Sent status request ${requestId} to ${requestTopic}`);

        // Set timeout for request
        setTimeout(() => {
          if (this.pendingRequests.has(requestId)) {
            this.pendingRequests.delete(requestId);
            this.session.unsubscribe(replyDestination, true, replyToTopic, 10000);
            reject(new Error('Request timeout'));
          }
        }, 10000); // 10 second timeout

      } catch (error) {
        console.error('Failed to send status request:', error);
        reject(error);
      }
    });
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  subscribe(topic: string, onFrame: (imageData: string) => void): void {
    this.onFrameCallback = onFrame;

    if (DEMO_MODE || (this.session && this.session.demo)) {
      console.log(`Demo mode: Subscribing to ${topic}`);
      this.startDemoVideoFeed();
      return;
    }

    if (!this.session || !this.isConnected) {
      console.error('Solace session not connected');
      return;
    }
    
    try {
      // Subscribe to metadata topic
      const metadataTopic = this.solaceApi.SolclientFactory.createTopicDestination(`${topic}/metadata`);
      this.session.subscribe(metadataTopic, true, `${topic}/metadata`, 10000);
      this.subscriptions.add(`${topic}/metadata`);
      
      // Subscribe to chunks topic
      const chunksTopic = this.solaceApi.SolclientFactory.createTopicDestination(`${topic}/chunks`);
      this.session.subscribe(chunksTopic, true, `${topic}/chunks`, 10000);
      this.subscriptions.add(`${topic}/chunks`);
      
      console.log(`Subscribed to video feed topics for: ${topic}`);
    } catch (error) {
      console.error('Failed to subscribe to topics:', error);
    }
  }

  private startDemoVideoFeed(): void {
    // Clear any existing interval
    if (this.demoInterval) {
      clearInterval(this.demoInterval);
    }

    // Generate demo video frames
    this.demoInterval = window.setInterval(() => {
      if (this.onFrameCallback) {
        const canvas = document.createElement('canvas');
        canvas.width = 640;
        canvas.height = 480;
        const ctx = canvas.getContext('2d');
        
        if (ctx) {
          // Create animated background
          const time = Date.now() / 1000;
          const gradient = ctx.createLinearGradient(0, 0, 640, 480);
          gradient.addColorStop(0, `hsl(${(time * 30) % 360}, 70%, 50%)`);
          gradient.addColorStop(1, `hsl(${(time * 30 + 180) % 360}, 70%, 30%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 640, 480);
          
          // Add moving elements
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          const x = (Math.sin(time) * 200) + 320;
          const y = (Math.cos(time * 0.7) * 150) + 240;
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.fill();
          
          // Add timestamp
          ctx.fillStyle = 'white';
          ctx.font = '20px Arial';
          ctx.fillText(new Date().toLocaleTimeString(), 20, 40);
          
          // Add GTAA branding
          ctx.fillStyle = '#003366';
          ctx.font = 'bold 24px Arial';
          ctx.fillText('GTAA Camera Feed (Demo)', 20, 80);
          
          // Add demo indicator
          ctx.fillStyle = '#ff6b35';
          ctx.font = '16px Arial';
          ctx.fillText('DEMO MODE', 20, 110);
          
          const imageData = canvas.toDataURL('image/jpeg', 0.8);
          this.onFrameCallback(imageData);
        }
      }
    }, 100); // 10 FPS
  }

  private handleMessage(message: any): void {
    try {
      const topic = message.getDestination().getName();
      const payload = JSON.parse(message.getBinaryAttachment());

      // Handle reply messages
      if (topic.includes('gtaa/camera/control/reply/')) {
        const requestId = topic.split('/').pop();
        if (requestId && this.pendingRequests.has(requestId)) {
          const callback = this.pendingRequests.get(requestId);
          this.pendingRequests.delete(requestId);
          if (callback) {
            callback(payload);
          }
        }
        return;
      }

      // Handle video feed messages
      if (topic.endsWith('/metadata')) {
        this.handleMetadataMessage(payload);
      } else if (topic.endsWith('/chunks')) {
        this.handleChunkMessage(payload);
      }
    } catch (error) {
      console.error('Error handling message:', error);
    }
  }

  private handleMetadataMessage(payload: any): void {
    if (payload.type === 'frame_start') {
      // Initialize frame assembly
      this.frameMetadata.set(payload.frameId, payload);
      this.frameChunks.set(payload.frameId, new Map());
      console.log(`Starting frame assembly for ${payload.frameId}, expecting ${payload.totalChunks} chunks`);
    } else if (payload.type === 'frame_end') {
      // Complete frame assembly
      this.assembleFrame(payload.frameId);
    }
  }

  private handleChunkMessage(payload: any): void {
    if (payload.type === 'frame_chunk') {
      const frameChunks = this.frameChunks.get(payload.frameId);
      if (frameChunks) {
        frameChunks.set(payload.chunkIndex, payload.data);
        
        // Check if we have all chunks
        const metadata = this.frameMetadata.get(payload.frameId);
        if (metadata && frameChunks.size === metadata.totalChunks) {
          this.assembleFrame(payload.frameId);
        }
      }
    }
  }

  private assembleFrame(frameId: string): void {
    const metadata = this.frameMetadata.get(frameId);
    const chunks = this.frameChunks.get(frameId);

    if (!metadata || !chunks) {
      console.warn(`Missing data for frame ${frameId}`);
      return;
    }

    try {
      // Assemble chunks in order
      let frameData = '';
      for (let i = 0; i < metadata.totalChunks; i++) {
        const chunk = chunks.get(i);
        if (chunk) {
          frameData += chunk;
        } else {
          console.warn(`Missing chunk ${i} for frame ${frameId}`);
          return;
        }
      }

      // Convert base64 to data URL
      const imageData = `data:image/jpeg;base64,${frameData}`;
      
      // Call the frame callback
      if (this.onFrameCallback) {
        this.onFrameCallback(imageData);
      }

      // Clean up
      this.frameMetadata.delete(frameId);
      this.frameChunks.delete(frameId);

    } catch (error) {
      console.error('Error assembling frame:', error);
    }
  }

  publishControl(topic: string, payload: any): void {
    if (DEMO_MODE || (this.session && this.session.demo)) {
      console.log(`Demo mode: Publishing control message to ${topic}:`, payload);
      return;
    }

    if (!this.session || !this.isConnected) {
      console.warn('Solace session not connected, cannot publish control message');
      return;
    }

    try {
      const message = this.solaceApi.SolclientFactory.createMessage();
      const destination = this.solaceApi.SolclientFactory.createTopicDestination(topic);
      
      message.setDestination(destination);
      message.setBinaryAttachment(JSON.stringify(payload));
      message.setDeliveryMode(this.solaceApi.MessageDeliveryModeType.DIRECT);
      
      this.session.send(message);
      console.log(`Published control message to ${topic}:`, payload);
    } catch (error) {
      console.error('Failed to publish control message:', error);
    }
  }

  unsubscribe(topic: string): void {
    if (DEMO_MODE || (this.session && this.session.demo)) {
      console.log(`Demo mode: Unsubscribing from ${topic}`);
      if (this.demoInterval) {
        clearInterval(this.demoInterval);
        this.demoInterval = undefined;
      }
      return;
    }

    if (!this.session || !this.isConnected) {
      return;
    }

    try {
      // Unsubscribe from metadata topic
      const metadataTopic = this.solaceApi.SolclientFactory.createTopicDestination(`${topic}/metadata`);
      if (this.subscriptions.has(`${topic}/metadata`)) {
        this.session.unsubscribe(metadataTopic, true, `${topic}/metadata`, 10000);
        this.subscriptions.delete(`${topic}/metadata`);
      }
      
      // Unsubscribe from chunks topic
      const chunksTopic = this.solaceApi.SolclientFactory.createTopicDestination(`${topic}/chunks`);
      if (this.subscriptions.has(`${topic}/chunks`)) {
        this.session.unsubscribe(chunksTopic, true, `${topic}/chunks`, 10000);
        this.subscriptions.delete(`${topic}/chunks`);
      }
      
      console.log(`Unsubscribed from video feed topics for: ${topic}`);
    } catch (error) {
      console.error('Failed to unsubscribe from topics:', error);
    }
  }

  disconnect(): void {
    // Clear demo interval
    if (this.demoInterval) {
      clearInterval(this.demoInterval);
      this.demoInterval = undefined;
    }

    // Clear pending requests
    this.pendingRequests.clear();

    if (DEMO_MODE || (this.session && this.session.demo)) {
      console.log('Demo mode: Disconnecting');
      this.session = null;
      this.isConnected = false;
      return;
    }

    if (this.session) {
      try {
        // Unsubscribe from all topics
        this.subscriptions.forEach(topic => {
          const destination = this.solaceApi.SolclientFactory.createTopicDestination(topic);
          this.session.unsubscribe(destination, true, topic, 10000);
        });
        this.subscriptions.clear();

        // Disconnect session
        this.session.disconnect();
        this.session.dispose();
        this.session = null;
        this.isConnected = false;
        
        console.log('Disconnected from Solace PubSub+');
      } catch (error) {
        console.error('Error during disconnect:', error);
      }
    }
  }

  isSessionConnected(): boolean {
    return this.isConnected && this.session !== null;
  }
}